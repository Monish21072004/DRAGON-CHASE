<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dragon Chase</title>
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#0d1a2f"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="data:application/manifest+json;base64,ewogICJuYW1lIjogIkRyYWdvbiBDaGFzZSIsCiAgInNob3J0X25hbWUiOiAiRHJhZ29uQ2hhc2UiLAogICJpY29ucyI6IFsKICAgIHsKICAgICAgInNyYyI6ICJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgcng9IjIwIiBmaWxsPSIjMGQxYTJmIi8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZkNzAwIiBzdHJva2Utd2lkdGg9IjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTSAzMCw3MCBDIDQwLDMwIDcwLDMwIDgwLDQwIFEgOTAsNTAgODAsNjAgQyA3MCw3MCA0MCw4MCAzMCw3MCBaIE0gODAsNDAgTCA4NSwzNSBNIDgwLDQwIEwgNzUsMzUgTSA2MCw0NSBBIDUgNSAwIDAgMSA2MCA1NSA1IDUgMCAwIDEgNjAgNDUgWiIgLz48L3N2Zz4iLAogICAgICAic2l6ZXMiOiAiMTkyeDE5MiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9LAogICAgewogICAgICAic3JjIjogImRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQ,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cmVjdCB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgcng9IjIwIiBmaWxsPSIjMGQxYTJmIi8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjZmZkNzAwIiBzdHJva2Utd2lkdGg9IjUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTSAzMCw3MCBDIDQwLDMwIDcwLDMwIDgwLDQwIFEgOTAsNTAgODAsNjAgQyA3MCw3MCA0MCw4MCAzMCw3MCBaIE0gODAsNDAgTCA4NSwzNSBNIDgwLDQwIEwgNzUsMzUgTSA2MCw0NSBBIDUgNSAwIDAgMSA2MCA1NSA1IDUgMCAwIDEgNjAgNDUgWiIgLz48L3N2Zz4iLAogICAgICAic2l6ZXMiOiAiNTEyeDUxMiIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXSwKICAic3RhcnRfdXJsIjogIi4iLAogICJkaXNwbGF5IjogImZ1bGxzY3JlZW4iLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMwMDAwMDAiLAogICJ0aGVtZV9jb2xvciI6ICIjMGQxYTJmIgp9">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            color: white;
            background: #000000;
            cursor: none;
            touch-action: none; /* Prevents touch scrolling/actions */
        }
        canvas {
            display: block;
            background: #000;
            transition: filter 0.5s;
        }
        #start-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Cinzel Decorative', cursive;
            font-size: 32px;
            cursor: pointer;
            z-index: 100;
        }
        .ui-element {
            position: absolute;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 170, 255, 0.5);
            border: 1px solid rgba(0, 170, 255, 0.7);
            pointer-events: none;
        }
        #ui-container {
            top: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        #score-container {
            display: flex;
            align-items: baseline;
            gap: 15px;
        }
        #timer, #difficulty, #score, #dash-status {
            font-size: 20px;
            font-weight: bold;
        }
        #multiplier {
            font-size: 24px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 5px #ffd700;
            transition: transform 0.1s;
        }
        #dash-status.ready { color: #4dff88; }
        #dash-status.cooldown { color: #ffcc00; }
        #dash-status.mega { color: #ff4d4d; animation: pulse 1s infinite; }
        
        #combo-bar-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 10px;
            background: rgba(255,255,255,0.2);
            border-radius: 5px;
            display: none;
        }
        #combo-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ffd700, #ff8c00);
            border-radius: 5px;
            transition: width 0.1s linear;
        }

        .modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: radial-gradient(circle, #1a3a6e, #0d1a2f);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            flex-direction: column;
            align-items: center;
            border: 2px solid #FFD700;
            box-shadow: 0 0 35px #ff8c00;
            width: 450px;
            max-width: 90vw;
            box-sizing: border-box;
            max-height: 80vh;
            overflow-y: auto;
            cursor: default; /* Make cursor visible over modals */
        }
        
        /* Custom Scrollbar for modals */
        .modal::-webkit-scrollbar {
            width: 12px;
        }
        .modal::-webkit-scrollbar-track {
            background: #0d1a2f;
            border-radius: 10px;
        }
        .modal::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, #ffd700, #ff8c00);
            border-radius: 10px;
            border: 2px solid #0d1a2f;
        }
        
        #game-over-modal, #pause-modal, #rules-modal, #shop-modal, #reset-confirm-modal, #start-modal { display: none; }
        
        .modal h1 {
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            font-size: 52px;
            color: #ffd700;
            text-shadow: 0 0 10px #ff8c00, 0 0 20px #ff8c00;
            margin: 0 0 30px 0;
        }
        #game-over-modal h1, #reset-confirm-modal h1 { color: #ff4d4d; }
        .modal h2 {
            font-family: 'Cinzel Decorative', cursive;
            color: #ffd700;
            text-align: left;
            width: 100%;
            border-bottom: 1px solid rgba(255,215,0,0.5);
            padding-bottom: 5px;
            margin-bottom: 15px;
        }
        .modal p { font-size: 20px; margin-bottom: 15px; }
        #high-score, #coin-display { font-size: 24px; color: #ffd700; margin-top: 10px; }
        .modal button {
            padding: 15px 30px;
            font-size: 20px;
            font-family: 'Cinzel Decorative', cursive;
            font-weight: 700;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            color: white;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
            background: linear-gradient(145deg, #0077cc, #00aaff);
            transition: all 0.2s ease;
            box-shadow: 0 5px #0055aa;
            pointer-events: all;
            margin-top: 10px;
        }
        .modal button:hover {
            background: linear-gradient(145deg, #33bbff, #66ccff);
            box-shadow: 0 5px #0077cc, 0 0 20px #33bbff;
            transform: translateY(-2px);
        }
        .modal button:active {
            transform: translateY(2px);
            box-shadow: 0 3px #0077cc;
        }
        
        .main-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 20px;
        }
        .main-menu-buttons button { margin: 0; width: 250px; }
        #reset-button {
            background: linear-gradient(145deg, #a00, #d33);
            box-shadow: 0 5px #800;
            font-size: 16px;
            padding: 10px 20px;
            width: 200px !important;
            margin-top: 20px;
        }
        #reset-button:hover {
             background: linear-gradient(145deg, #c00, #f66);
             box-shadow: 0 5px #a00, 0 0 20px #f66;
        }

        /* Rules Modal Improvements */
        #rules-modal p, #rules-modal li { text-align: left; font-size: 16px; line-height: 1.6; }
        #rules-modal strong { color: #ffd700; }
        #rules-modal > ul > li { margin-bottom: 20px; }
        #rules-modal ul { list-style: none; padding: 0;}
        #rules-modal .powerups-list {
            padding: 15px;
            margin-top: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }
        #rules-modal li { margin-bottom: 12px; display: flex; align-items: center;}
        .orb-preview { 
            width: 24px; 
            height: 24px; 
            margin-right: 12px; 
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            box-sizing: border-box;
        }
        
        .orb-shield {
            background: #0096FF; border: 2px solid white; width: 22px; height: 24px;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }
        .orb-slowmo {
            background: #32FF96; border: 2px solid white; border-radius: 50%;
        }
        .orb-slowmo::before, .orb-slowmo::after {
            content: ''; position: absolute; background: white; left: 50%; top: 2px; transform-origin: 50% 100%;
        }
        .orb-slowmo::before { width: 2px; height: 8px; transform: translateX(-50%) rotate(20deg); }
        .orb-slowmo::after { width: 2px; height: 5px; transform: translateX(-50%) rotate(90deg); }
        .orb-mega {
            background: #FF3232; border: 2px solid #ff8c00; border-radius: 50%;
        }
        .orb-mega::before {
             content: ''; position: absolute; width: 100%; height: 100%;
             background: repeating-radial-gradient(circle at 50% 50%, #ff8c00 0, #ff8c00 1px, transparent 1px, transparent 5px);
             transform: scale(1.5); opacity: 0.7;
        }
        .orb-magnet {
             width: 18px; height: 18px; border: 4px solid #FFFF00; border-top-color: transparent;
             border-radius: 50%; background: transparent !important;
        }
        .orb-magnet::before, .orb-magnet::after {
            content: ''; position: absolute; width: 4px; height: 4px; background: #c0c0c0; bottom: -4px;
        }
        .orb-magnet::before { left: -4px; }
        .orb-magnet::after { right: -4px; }
        .orb-coin {
            background: radial-gradient(circle, #fff, #ccc); border-radius: 50%;
            color: #333; font-size: 10px; font-weight: bold; font-family: sans-serif;
        }


        #shop-container { width: 100%;}
        .shop-item { 
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            margin-bottom: 15px; 
            background: rgba(0,0,0,0.3); 
            padding: 15px; 
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.5);
        }
        .shop-item p { margin: 0; text-align: left; line-height: 1.2;}
        .shop-item button { font-size: 14px; padding: 8px 15px; margin-top: 0;}
        .shop-item button:disabled { background: #555; box-shadow: 0 5px #333; cursor: not-allowed;}
        .item-cost { font-weight: bold; color: #ffd700;}
        .shop-item span { font-size: 14px; color: #ccc; }
        
        #cursor-skin-shop .shop-item { 
            flex-direction: column; 
            align-items: stretch;
            gap: 10px;
        }
        .cursor-skin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        .skin-description {
            font-size: 14px;
            color: #ccc;
            text-align: left;
            margin-top: 5px;
            font-style: italic;
        }
        #cursor-skin-container { display: grid; grid-template-columns: 1fr; gap: 10px; }


        @keyframes pulse {
            0% { text-shadow: 0 0 5px #ff4d4d; }
            50% { text-shadow: 0 0 20px #ff4d4d; }
            100% { text-shadow: 0 0 5px #ff4d4d; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        @media (max-width: 600px) {
            #ui-container {
                top: 10px;
                left: 10px;
                font-size: 14px;
            }
            .modal h1 {
                font-size: 32px;
            }
             .modal p {
                font-size: 16px;
            }
             .modal button {
                padding: 12px 24px;
                font-size: 16px;
            }
            #mobile-pushback {
                padding: 15px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="start-overlay">Tap to Start</div>

    <canvas id="gameCanvas"></canvas>
    
    <div id="ui-container" class="ui-element" style="display: none;">
        <div id="timer">Time: 0.0s</div>
        <div id="difficulty">Difficulty: 1</div>
        <div id="score-container">
            <div id="score">Score: 0</div>
            <div id="multiplier"></div>
        </div>
        <div id="dash-status" class="ready">Pushback: READY</div>
    </div>

    <div id="combo-bar-container">
        <div id="combo-bar"></div>
    </div>

    <div id="start-modal" class="modal">
        <h1>DRAGON CHASE</h1>
        <div class="main-menu-buttons">
            <button id="play-button">Play</button>
            <button id="shop-button">Shop</button>
            <button id="rules-button">Rules</button>
        </div>
        <p id="high-score">High Score: 0</p>
        <p id="coin-display">Coins: 0</p>
        <button id="reset-button">Reset Progress</button>
    </div>

    <div id="rules-modal" class="modal">
        <h1>How to Play</h1>
        <ul>
            <li><p><strong>Objective:</strong> Survive as long as possible while scoring points by collecting orbs.</p></li>
            <li><p id="controls-rule"><strong>Controls:</strong> Move your cursor/finger to navigate. Press [SPACE] for a defensive Pushback.</p></li>
            <li><strong>Scoring:</strong> Collect yellow orbs for points. Grab them quickly to build a score multiplier!</li>
            <li><strong>Dangers:</strong> Avoid the dragon, its attacks, and the fiery meteorites! The dragon evolves and gains new attacks as you survive longer.</li>
            <li><strong>Power-ups:</strong>
                <ul class="powerups-list">
                    <li><div class="orb-preview orb-shield"></div>Blue Orb: Temporary Shield.</li>
                    <li><div class="orb-preview orb-slowmo"></div>Green Orb: Slows the dragon.</li>
                    <li><div class="orb-preview orb-mega"></div>Red Orb: Mega Pushback.</li>
                    <li><div class="orb-preview orb-magnet"></div>Yellow Orb: Orb Magnet.</li>
                    <li><div class="orb-preview orb-coin">2x</div>White Orb: Doubles coins earned this run.</li>
                </ul>
            </li>
        </ul>
        <button id="rules-back-button">Back to Menu</button>
    </div>

     <div id="shop-modal" class="modal">
        <h1>Upgrade Shop</h1>
        <div id="shop-container">
            <h2>Abilities</h2>
            <div class="shop-item">
                <p>Pushback Cooldown<br><span id="cooldown-level"></span></p>
                <button id="buy-cooldown" data-cost="100">Buy <span class="item-cost">100</span></button>
            </div>
            <div class="shop-item">
                <p>Power-up Duration<br><span id="duration-level"></span></p>
                <button id="buy-duration" data-cost="150">Buy <span class="item-cost">150</span></button>
            </div>
            <div class="shop-item">
                <p>Starting Shield<br><span id="shield-level"></span></p>
                <button id="buy-shield" data-cost="500">Buy <span class="item-cost">500</span></button>
            </div>
            <div id="cursor-skin-shop">
                <h2>Cursor Skins</h2>
                <div id="cursor-skin-container"></div>
            </div>
        </div>
        <p id="shop-coin-display">Coins: 0</p>
        <button id="shop-back-button">Back to Menu</button>
    </div>

    <div id="reset-confirm-modal" class="modal">
        <h1>Reset Progress</h1>
        <p>Are you sure you want to erase all your coins, upgrades, and high scores? This action cannot be undone.</p>
        <div>
            <button id="confirm-reset-button" style="background: linear-gradient(145deg, #a00, #d33); box-shadow: 0 5px #800;">Yes, Reset</button>
            <button id="cancel-reset-button">Cancel</button>
        </div>
    </div>


    <div id="pause-modal" class="modal">
        <h1>PAUSED</h1>
        <p>Press 'P' to resume</p>
    </div>

    <div id="game-over-modal" class="modal">
        <h1>GAME OVER</h1>
        <p id="final-time">You survived for: 0.0s</p>
        <p id="final-score">Final Score: 0</p>
        <p id="coins-earned">Coins Earned: 0</p>
        <button id="restart-button">Play Again</button>
        <button id="main-menu-button">Main Menu</button>
        <p id="final-high-score">High Score: 0</p>
    </div>
    
    <button id="mobile-pushback" style="
        position: fixed;
        bottom: 20px;
        right: 20px;
        padding: 20px;
        font-size: 18px;
        border: none;
        border-radius: 50%;
        background: linear-gradient(145deg, #0077cc, #00aaff);
        color: white;
        box-shadow: 0 5px #0055aa;
        z-index: 100;
        display: none;
        cursor: pointer;
    ">⚡</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // --- UI ELEMENTS ---
        const startOverlay = document.getElementById('start-overlay');
        const uiContainer = document.getElementById('ui-container');
        const timerElement = document.getElementById('timer');
        const difficultyElement = document.getElementById('difficulty');
        const scoreElement = document.getElementById('score');
        const multiplierElement = document.getElementById('multiplier');
        const dashStatusElement = document.getElementById('dash-status');
        const finalTimeElement = document.getElementById('final-time');
        const finalScoreElement = document.getElementById('final-score');
        const coinsEarnedElement = document.getElementById('coins-earned');
        const restartButton = document.getElementById('restart-button');
        const mainMenuButton = document.getElementById('main-menu-button');
        const mobilePushbackButton = document.getElementById('mobile-pushback');
        
        // --- MENU & MODAL BUTTONS ---
        const playButton = document.getElementById('play-button');
        const shopButton = document.getElementById('shop-button');
        const rulesButton = document.getElementById('rules-button');
        const resetButton = document.getElementById('reset-button');
        const confirmResetButton = document.getElementById('confirm-reset-button');
        const cancelResetButton = document.getElementById('cancel-reset-button');
        const rulesBackButton = document.getElementById('rules-back-button');
        const shopBackButton = document.getElementById('shop-back-button');

        // --- MODALS ---
        const gameOverModal = document.getElementById('game-over-modal');
        const startModal = document.getElementById('start-modal');
        const pauseModal = document.getElementById('pause-modal');
        const rulesModal = document.getElementById('rules-modal');
        const shopModal = document.getElementById('shop-modal');
        const resetConfirmModal = document.getElementById('reset-confirm-modal');
        
        const highScoreElement = document.getElementById('high-score');
        const finalHighScoreElement = document.getElementById('final-high-score');
        const coinDisplay = document.getElementById('coin-display');
        const comboBarContainer = document.getElementById('combo-bar-container');
        const comboBar = document.getElementById('combo-bar');

        // --- SHOP UI ---
        const shopCoinDisplay = document.getElementById('shop-coin-display');
        const buyCooldownButton = document.getElementById('buy-cooldown');
        const buyDurationButton = document.getElementById('buy-duration');
        const buyShieldButton = document.getElementById('buy-shield');
        const cooldownLevelEl = document.getElementById('cooldown-level');
        const durationLevelEl = document.getElementById('duration-level');
        const shieldLevelEl = document.getElementById('shield-level');
        const cursorSkinContainer = document.getElementById('cursor-skin-container');


        let isGameOver = false, isPaused = false, isGameStarted = false;
        let animationFrameId;

        let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let cursorTarget = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        let dragon = { 
            segments: [], speed: 2.0, length: 30, baseRadius: 15, frozenTimer: 0,
            fireBreathCooldown: 0, tailWhipCooldown: 0, summonCooldown: 0, whelp: null
        };
        let gameState = { 
            startTime: 0, difficulty: 1, score: 0, highScore: 0, coins: 0,
            multiplier: 1, comboTimer: 0, maxComboTime: 2000, coinDoubler: false,
            cursorSize: 1.0, baseHitboxRadius: 35
        };
        let particles = [], orbs = [], mines = [], starfield = [], fireParticles = [], tailShockwaves = [];
        
        const cursorSkins = {
            'default': { name: 'Celestial Wisp', cost: 0, description: 'A standard, well-balanced cursor with no special abilities.' },
            'sunstone': { name: 'Sunstone Shard', cost: 750, description: 'Has a small chance to vaporize a nearby meteorite when you collect an orb.' },
            'vortex': { name: 'Void Eater', cost: 1500, description: 'Passively pulls in orbs from a short distance.' },
            'frost': { name: 'Frost Locus', cost: 2500, description: 'Collecting an orb has a chance to briefly freeze the dragon.' }
        };

        let upgrades = {
            cooldownReduction: 0, // level
            durationIncrease: 0,  // level
            startingShield: false, // boolean
            cursorSkin: 'default',
            purchasedSkins: ['default']
        };

        let dash = { ready: true, cooldown: 5000, timer: 0, shockwave: null, isMega: false };
        let powerups = { 
            shield: { active: false, timer: 0, duration: 5000 }, 
            slowmo: { active: false, timer: 0, duration: 5000 },
            magnet: { active: false, timer: 0, duration: 6000 }
        };

        const synth = new Tone.PolySynth(Tone.Synth).toDestination();
        const musicLoop = new Tone.Loop(time => {
            synth.triggerAttackRelease(["C2", "G2", "Eb2"], "2n", time);
        }, "1n").start(0);
        Tone.Transport.bpm.value = 80;

        function playSound(note, duration = "16n") {
            if (Tone.context.state !== 'running') return;
            synth.triggerAttackRelease(note, duration);
        }

        function createStarfield() {
            starfield = [];
            for (let i = 0; i < 500; i++) {
                starfield.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: Math.random() * 2 + 0.5,
                    layer: Math.floor(Math.random() * 3) + 1
                });
            }
        }
        
        function init() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            createStarfield();

            dragon.segments = [];
            dragon.length = 30; // Reset length
            dragon.frozenTimer = 0;
            dragon.fireBreathCooldown = 5000;
            dragon.tailWhipCooldown = 8000;
            dragon.summonCooldown = 15000;
            dragon.whelp = null;

            for (let i = 0; i < dragon.length; i++) dragon.segments.push({ x: -100, y: -100, angle: 0 });
            
            gameState.startTime = Date.now();
            gameState.difficulty = 1;
            gameState.score = 0;
            gameState.multiplier = 1;
            gameState.coinDoubler = false;
            gameState.cursorSize = 1.0;
            updateScoreUI();
            updateMultiplierUI();

            dragon.speed = 2.0;
            isGameOver = false;
            isPaused = false;
            dash.ready = true;
            dash.timer = 0;
            dash.isMega = false;
            Object.keys(powerups).forEach(key => powerups[key].active = false);

            // Apply starting shield upgrade
            if(upgrades.startingShield) {
                powerups.shield.active = true;
                powerups.shield.timer = powerups.shield.duration + (upgrades.durationIncrease * 500);
            }
            
            dash.cooldown = 5000 - (upgrades.cooldownReduction * 250);

            orbs = []; mines = []; fireParticles = []; tailShockwaves = [];
            for (let i = 0; i < 10; i++) spawnOrb('normal');
            
            particles = [];
            
            gameOverModal.style.display = 'none';
            pauseModal.style.display = 'none';
            uiContainer.style.display = 'flex';
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }

        function gameLoop() {
            if (animationFrameId && (isGameOver || !isGameStarted)) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            if (!isGameStarted) {
                drawMainMenuBackground();
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            if (isGameOver) return;

            if (!isPaused) update();
            
            draw();

            if (!isGameOver) {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        function update() {
            updateCursor();
            const effectiveSpeed = powerups.slowmo.active ? dragon.speed * 0.5 : dragon.speed;
            updateDragon(effectiveSpeed);
            updateDragonPowers();
            if (!powerups.shield.active) checkCollision();
            updateDifficulty();
            updateParticles();
            updateOrbs();
            updateMines();
            updateDash();
            updatePowerups();
            updateCombo();
            updateStarfield();
        }
        
        function updateCursor() {
            const dx = cursorTarget.x - mouse.x;
            const dy = cursorTarget.y - mouse.y;
            const dist = Math.hypot(dx, dy);

            if (dist < 1) {
                mouse.x = cursorTarget.x;
                mouse.y = cursorTarget.y;
                return;
            }
            
            const lerpFactor = 0.4; 
            mouse.x += dx * lerpFactor;
            mouse.y += dy * lerpFactor;
        }

        function updateDragon(currentSpeed) {
            if (!dragon.segments || dragon.segments.length === 0) return; 

            if (dragon.frozenTimer > 0) {
                dragon.frozenTimer -= 16.67;
                return; // Skip movement if frozen
            }
            
            const head = dragon.segments[0];
            let angle = Math.atan2(mouse.y - head.y, mouse.x - head.x);
            head.angle = angle;
            
            if (dash.shockwave) {
                const dx = head.x - dash.shockwave.x;
                const dy = head.y - dash.shockwave.y;
                const dist = Math.hypot(dx, dy);
                if (dist < dash.shockwave.radius) {
                    const pushForce = (dash.shockwave.radius - dist) * 0.1;
                    angle = Math.atan2(dy, dx);
                    head.x += Math.cos(angle) * pushForce;
                    head.y += Math.sin(angle) * pushForce;
                }
            }

            head.x += Math.cos(angle) * currentSpeed;
            head.y += Math.sin(angle) * currentSpeed;

            for (let i = 1; i < dragon.segments.length; i++) {
                const seg = dragon.segments[i], prevSeg = dragon.segments[i - 1];
                 if (!prevSeg) continue;
                const dx = prevSeg.x - seg.x, dy = prevSeg.y - seg.y;
                const distAngle = Math.atan2(dy, dx);
                seg.angle = distAngle;
                const separation = 10; 
                if (Math.hypot(dx, dy) > separation) {
                    seg.x = prevSeg.x - Math.cos(distAngle) * separation;
                    seg.y = prevSeg.y - Math.sin(distAngle) * separation;
                }
            }
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                if (p.isBurst) { p.x += p.vx; p.y += p.vy; }
                p.size *= 0.95; p.life--;
                if (p.life <= 0 || p.size < 0.2) particles.splice(i, 1);
            }
            for (let i = fireParticles.length - 1; i >= 0; i--) {
                const p = fireParticles[i];
                p.x += p.vx; p.y += p.vy;
                p.vy += 0.05; // gravity
                p.size *= 0.96; p.life--;
                if (p.life <= 0 || p.size < 0.5) fireParticles.splice(i, 1);
            }
        }
        
        function updateStarfield() {
             starfield.forEach(star => {
                const mouseEffectX = (mouse.x - canvas.width/2);
                const mouseEffectY = (mouse.y - canvas.height/2);

                star.x -= (mouseEffectX / (2000 / star.layer));
                star.y -= (mouseEffectY / (2000 / star.layer));


                if (star.x < 0) star.x = canvas.width;
                if (star.x > canvas.width) star.x = 0;
                if (star.y < 0) star.y = canvas.height;
                if (star.y > canvas.height) star.y = 0;
            });
        }


        function updateOrbs() {
            for (let i = orbs.length - 1; i >= 0; i--) {
                const orb = orbs[i];
                let dist = Math.hypot(mouse.x - orb.x, mouse.y - orb.y);
                
                let magnetRadius = 0;
                if (powerups.magnet.active) magnetRadius = 150;
                else if (upgrades.cursorSkin === 'vortex') magnetRadius = 75; // Passive magnet power

                if (magnetRadius > 0 && dist < magnetRadius) {
                    const angle = Math.atan2(mouse.y - orb.y, mouse.x - orb.x);
                    orb.x += Math.cos(angle) * 5;
                    orb.y += Math.sin(angle) * 5;
                    dist = Math.hypot(mouse.x - orb.x, mouse.y - orb.y);
                }

                if (dist < 20) {
                    collectOrb(orb);
                    orbs.splice(i, 1);
                }
            }
            if (orbs.length < 15 && Math.random() < 0.03) {
                const rand = Math.random();
                if (rand < 0.05) spawnOrb('shield');
                else if (rand < 0.1) spawnOrb('slowmo');
                else if (rand < 0.15) spawnOrb('mega');
                else if (rand < 0.20) spawnOrb('magnet');
                else if (rand < 0.22) spawnOrb('coinDoubler');
                else spawnOrb('normal');
            }
        }

        function updateMines() {
            if (mines.length < gameState.difficulty && Math.random() < 0.01) {
                spawnMine();
            }
            mines.forEach(mine => {
                mine.angle += mine.rotationSpeed;
                mine.pulse = Math.sin(Date.now() / 300) * 5;
            });
        }
        
        function updateCombo() {
            if (gameState.comboTimer > 0) {
                gameState.comboTimer -= 16.67;
                comboBarContainer.style.display = 'block';
                comboBar.style.width = `${(gameState.comboTimer / gameState.maxComboTime) * 100}%`;
            } else {
                if(gameState.multiplier > 1) {
                    gameState.multiplier = 1;
                    updateMultiplierUI();
                }
                comboBarContainer.style.display = 'none';
            }
        }

        function updateDragonPowers() {
            const delta = 16.67;
            if (dragon.frozenTimer > 0) return;

            // Fire Breath
            if (gameState.difficulty >= 8) {
                dragon.fireBreathCooldown -= delta;
                if (dragon.fireBreathCooldown <= 0) {
                    dragon.fireBreathCooldown = 8000 + Math.random() * 2000;
                    const head = dragon.segments[0];
                    const angle = head.angle;
                    for (let i = 0; i < 30; i++) {
                        const spread = (Math.random() - 0.5) * 0.5;
                        const speed = 3 + Math.random() * 2;
                        fireParticles.push({
                            x: head.x + Math.cos(angle) * 30, y: head.y + Math.sin(angle) * 30,
                            vx: Math.cos(angle + spread) * speed, vy: Math.sin(angle + spread) * speed,
                            size: Math.random() * 5 + 3, life: 60
                        });
                    }
                    playSound("G2", "4n");
                }
            }

            // Tail Whip
            if (gameState.difficulty >= 12) {
                dragon.tailWhipCooldown -= delta;
                if (dragon.tailWhipCooldown <= 0) {
                    dragon.tailWhipCooldown = 6000 + Math.random() * 1500;
                    const tail = dragon.segments[dragon.segments.length - 1];
                    tailShockwaves.push({ x: tail.x, y: tail.y, radius: 10, opacity: 1, speed: 5 });
                    playSound("A3", "8n");
                }
            }
             for (let i = tailShockwaves.length - 1; i >= 0; i--) {
                const sw = tailShockwaves[i];
                sw.radius += sw.speed;
                sw.opacity -= 0.04;
                if (sw.opacity <= 0) tailShockwaves.splice(i, 1);
            }


            // Summon Whelp
            if (gameState.difficulty >= 18) {
                 dragon.summonCooldown -= delta;
                 if (dragon.summonCooldown <= 0 && !dragon.whelp) {
                     dragon.summonCooldown = 20000;
                     const spawnPos = dragon.segments[Math.floor(dragon.segments.length / 2)];
                     dragon.whelp = { x: spawnPos.x, y: spawnPos.y, size: 15, speed: 1.5, spawnTimer: 100 };
                     playSound("D3", "2n");
                 }
            }
            if (dragon.whelp) {
                if (dragon.whelp.spawnTimer > 0) {
                    dragon.whelp.spawnTimer--;
                } else {
                    const angle = Math.atan2(mouse.y - dragon.whelp.y, mouse.x - dragon.whelp.x);
                    dragon.whelp.x += Math.cos(angle) * dragon.whelp.speed;
                    dragon.whelp.y += Math.sin(angle) * dragon.whelp.speed;
                }
            }

        }


        function collectOrb(orb) {
            createParticleBurst(orb.x, orb.y, orb.color);
            
            gameState.score += Math.floor(10 * gameState.multiplier);
            
            const pitch = 200 + (gameState.multiplier * 50);
            playSound(pitch, "32n");
            
            gameState.multiplier += 0.2;
            gameState.comboTimer = gameState.maxComboTime;
            updateMultiplierUI();

            // Handle Cursor Powers on orb collect
            if (upgrades.cursorSkin === 'sunstone' && Math.random() < 0.15) { // 15% chance
                let closestMine = null;
                let minDist = 200; // Max radius to look for a mine
                mines.forEach(mine => {
                    const dist = Math.hypot(mouse.x - mine.x, mouse.y - mine.y);
                    if (dist < minDist) {
                        minDist = dist;
                        closestMine = mine;
                    }
                });
                if (closestMine) {
                    createParticleBurst(closestMine.x, closestMine.y, 'orange');
                    playSound("G2", "8n");
                    mines = mines.filter(m => m !== closestMine);
                }
            }
            if (upgrades.cursorSkin === 'frost' && Math.random() < 0.10) { // 10% chance
                dragon.frozenTimer = 750; // Freeze for 0.75 seconds
                playSound("C6", "16n");
                createParticleBurst(dragon.segments[0].x, dragon.segments[0].y, 'cyan');
            }
            
            const duration = powerups.shield.duration + (upgrades.durationIncrease * 500);

            switch(orb.type) {
                case 'shield': powerups.shield.active = true; powerups.shield.timer = duration; playSound("A4", "8n"); break;
                case 'slowmo': powerups.slowmo.active = true; powerups.slowmo.timer = duration; playSound("E4", "8n"); break;
                case 'magnet': powerups.magnet.active = true; powerups.magnet.timer = duration; playSound("B4", "8n"); break;
                case 'mega': dash.isMega = true; updateDashUI(); playSound("G4", "8n"); break;
                case 'coinDoubler': gameState.coinDoubler = true; playSound("C5", "8n"); break;
            }
            updateScoreUI();
        }

        function spawnOrb(type) {
            const orb = { x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: 8, type: type };
            const powerupColors = {
                shield: 'rgba(0, 150, 255, 1)', slowmo: 'rgba(50, 255, 150, 1)',
                mega: 'rgba(255, 50, 50, 1)', magnet: 'rgba(255, 255, 0, 1)',
                coinDoubler: 'radial-gradient(circle, #fff, #ccc)',
                normal: 'hsl(50, 100%, 70%)'
            };
            orb.color = powerupColors[type];
            orb.shadow = orb.color;
            if (type !== 'normal') orb.size = 12; // Make powerups bigger
            orbs.push(orb);
        }

        function spawnMine() {
            const radius = 15 + Math.random() * 10;
            const points = [];
            const numPoints = 8 + Math.floor(Math.random() * 5);
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const dist = radius * (0.8 + Math.random() * 0.4);
                points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
            }
            mines.push({
                x: Math.random() * canvas.width, y: Math.random() * canvas.height,
                radius: radius, points: points, angle: 0,
                rotationSpeed: (Math.random() - 0.5) * 0.02, pulse: 0
            });
        }

        function createParticleBurst(x, y, color) {
            for (let i=0; i<20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                particles.push({
                    x: x, y: y, size: Math.random() * 3 + 1, color: color, life: 30,
                    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, isBurst: true
                });
            }
        }
        
        function updateDash() {
            if (!dash.ready) {
                dash.timer -= 16.67;
                if (dash.timer <= 0) { dash.ready = true; dash.isMega = false; }
            }
            updateDashUI();
            if (dash.shockwave) {
                dash.shockwave.radius += dash.shockwave.speed;
                dash.shockwave.opacity -= 0.05;
                if (dash.shockwave.opacity <= 0) dash.shockwave = null;
            }
        }

        function updatePowerups() {
            for(const key in powerups) {
                if(powerups[key].active) {
                    powerups[key].timer -= 16.67;
                    if(powerups[key].timer <= 0) {
                        powerups[key].active = false;
                        if(key === 'slowmo') canvas.style.filter = 'none';
                    }
                }
            }
            if (powerups.slowmo.active) {
                canvas.style.filter = `blur(${Math.sin(powerups.slowmo.timer/500)*2}px) hue-rotate(60deg)`;
            }
        }

        function checkCollision() {
            if (!dragon.segments || dragon.segments.length === 0) return;
            const hitboxRadius = gameState.baseHitboxRadius * gameState.cursorSize;
            
            // Dragon Head and Meteorites
            if (Math.hypot(dragon.segments[0].x - mouse.x, dragon.segments[0].y - mouse.y) < hitboxRadius + 10) gameOver(); // +10 for dragon head size
            for (const mine of mines) {
                if (Math.hypot(mine.x - mouse.x, mine.y - mouse.y) < mine.radius + hitboxRadius) gameOver();
            }

            // Dragon Powers
            for (const p of fireParticles) {
                 if (Math.hypot(p.x - mouse.x, p.y - mouse.y) < p.size + hitboxRadius) gameOver();
            }
            for (const sw of tailShockwaves) {
                if (Math.hypot(sw.x - mouse.x, sw.y - mouse.y) < sw.radius) gameOver();
            }
            if (dragon.whelp && dragon.whelp.spawnTimer <= 0) {
                if(Math.hypot(dragon.whelp.x - mouse.x, dragon.whelp.y - mouse.y) < dragon.whelp.size + hitboxRadius) gameOver();
            }

        }

        function updateDifficulty() {
            const elapsedTime = (Date.now() - gameState.startTime) / 1000;
            timerElement.textContent = `Time: ${elapsedTime.toFixed(1)}s`;
            
            // Shrink cursor over time, down to a minimum size
            gameState.cursorSize = Math.max(0.3, 1 - (elapsedTime / 300)); // Shrinks to 30% over 5 minutes

            const newDifficulty = Math.floor(elapsedTime / 8) + 1;
            if (newDifficulty > gameState.difficulty) {
                gameState.difficulty = newDifficulty;
                dragon.speed += 0.15;
                dragon.length = Math.min(60, dragon.length + 2); // Cap length
                dragon.segments.push({ ...dragon.segments[dragon.segments.length-1] });
                dragon.segments.push({ ...dragon.segments[dragon.segments.length-1] });
                difficultyElement.textContent = `Difficulty: ${gameState.difficulty}`;
            }
        }
        
        function updateScoreUI() { scoreElement.textContent = `Score: ${gameState.score}`; }
        
        function updateMultiplierUI() {
            if (gameState.multiplier > 1) {
                multiplierElement.textContent = `x${gameState.multiplier.toFixed(1)}`;
                multiplierElement.style.transform = `scale(1.2)`;
                setTimeout(() => { multiplierElement.style.transform = `scale(1)`; }, 100);
            } else {
                multiplierElement.textContent = '';
            }
        }

        function updateDashUI() {
            if (dash.isMega) { dashStatusElement.textContent = 'Pushback: MEGA'; dashStatusElement.className = 'mega'; }
            else if (dash.ready) { dashStatusElement.textContent = 'Pushback: READY'; dashStatusElement.className = 'ready'; }
            else {
                const cooldownLeft = (dash.timer / 1000).toFixed(1);
                dashStatusElement.textContent = `Pushback: ${cooldownLeft}s`;
                dashStatusElement.className = 'cooldown';
            }
        }

        function gameOver() {
            isGameOver = true;
            canvas.style.filter = 'blur(5px)';
            uiContainer.style.display = 'none';
            comboBarContainer.style.display = 'none';

            playSound("C2", "1n");
            Tone.Transport.stop();
            
            const elapsedTime = ((Date.now() - gameState.startTime) / 1000).toFixed(1);
            
            let coinsEarned = Math.floor(gameState.score / 10);
            if(gameState.coinDoubler) coinsEarned *= 2;
            gameState.coins += coinsEarned;
            
            finalTimeElement.textContent = `You survived for: ${elapsedTime}s`;
            finalScoreElement.textContent = `Final Score: ${gameState.score}`;
            coinsEarnedElement.textContent = `Coins Earned: ${coinsEarned}`;
            
            if (gameState.score > gameState.highScore) {
                gameState.highScore = gameState.score;
            }
            saveGameData();
            
            finalHighScoreElement.textContent = `High Score: ${gameState.highScore}`;

            gameOverModal.style.display = 'flex';
            document.body.style.animation = 'shake 0.5s';
            setTimeout(() => document.body.style.animation = '', 500);
        }
        
        // --- DRAW FUNCTIONS ---

        function drawMainMenuBackground() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateStarfield();
            drawStarfield();
            drawCursor();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawStarfield();
            drawParticles(); 
            drawOrbs(); 
            drawMines(); 
            drawDragon();
            drawShockwave();
            if (powerups.shield.active) drawShield();
            if (powerups.magnet.active) drawMagnetEffect();
            drawCursor(); 
        }

        function drawStarfield() {
            starfield.forEach(star => {
                ctx.fillStyle = `rgba(255, 255, 255, ${0.2 + (star.layer-1) * 0.25})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        // --- CURSOR DRAWING ---
        function drawDefaultCursor(scale) {
             const time = Date.now() / 100;
            const radius1 = (10 + Math.sin(time) * 2) * scale;
            const radius2 = (5 + Math.cos(time) * 1) * scale;
            
            const grad = ctx.createRadialGradient(mouse.x, mouse.y, 1, mouse.x, mouse.y, 25 * scale);
            grad.addColorStop(0, 'rgba(173, 216, 230, 0.8)'); // LightBlue
            grad.addColorStop(1, 'rgba(173, 216, 230, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 25 * scale, 0, Math.PI * 2);
            ctx.fill();

            ctx.save();
            ctx.translate(mouse.x, mouse.y);
            ctx.rotate(time / 10);
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 1.5 * scale;
            ctx.beginPath();
            ctx.arc(0, 0, radius1, 0, Math.PI * 1.5);
            ctx.stroke();
            ctx.rotate(Math.PI / 2);
            ctx.beginPath();
            ctx.arc(0, 0, radius2, 0, Math.PI * 1.5);
            ctx.stroke();
            ctx.restore();
        }
        function drawSunstoneCursor(scale) {
            const time = Date.now();
            const baseSize = 20 * scale;
            ctx.save();
            ctx.translate(mouse.x, mouse.y);
            ctx.rotate(time / 1000);

            const grad = ctx.createRadialGradient(0, 0, baseSize * 0.2, 0, 0, baseSize);
            grad.addColorStop(0, 'rgba(255, 220, 150, 1)');
            grad.addColorStop(0.7, 'rgba(255, 100, 0, 0.8)');
            grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            for(let i=0; i<5; i++){
                const angle = i * Math.PI * 2 / 5;
                const x = Math.cos(angle) * baseSize * (1 + Math.sin(time/200 + i) * 0.1);
                const y = Math.sin(angle) * baseSize * (1 + Math.sin(time/200 + i) * 0.1);
                if(i===0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();

            // Embers
            if (Math.random() > 0.8) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.random() * baseSize;
                 particles.push({
                    x: mouse.x + Math.cos(angle) * dist, y: mouse.y + Math.sin(angle) * dist, 
                    size: Math.random() * 2 + 1, color: 'rgba(255, 150, 0, 0.8)', life: 20, isBurst: false
                });
            }

            ctx.restore();
        }
        function drawVortexCursor(scale) {
             const time = Date.now() / 500;
             const baseRadius = 25 * scale;
             ctx.save();
             ctx.translate(mouse.x, mouse.y);
             for(let i=0; i<15; i++) {
                const angle = time + i * 0.5;
                const radius = baseRadius * (i / 15);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                ctx.fillStyle = `rgba(138, 43, 226, ${1 - (i/20)})`;
                ctx.beginPath();
                ctx.arc(x, y, (1 - (i/15)) * 3 * scale, 0, Math.PI*2);
                ctx.fill();
             }
             ctx.restore();
        }
        function drawFrostCursor(scale) {
            const time = Date.now() / 800;
            const baseSize = 25 * scale;
            ctx.save();
            ctx.translate(mouse.x, mouse.y);
            ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + Math.sin(time*5)*0.2})`;
            ctx.lineWidth = 2 * scale;
            
            for(let i=0; i<6; i++) {
                ctx.rotate(Math.PI/3);
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.lineTo(0, -baseSize);
                ctx.moveTo(0, -baseSize * 0.3);
                ctx.lineTo(-baseSize * 0.2, -baseSize * 0.5);
                ctx.moveTo(0, -baseSize * 0.3);
                ctx.lineTo(baseSize * 0.2, -baseSize * 0.5);
                ctx.stroke();
            }
            ctx.restore();
        }

        function drawCursor() {
            const scale = gameState.cursorSize || 1.0;
            switch(upgrades.cursorSkin) {
                case 'sunstone': drawSunstoneCursor(scale); break;
                case 'vortex': drawVortexCursor(scale); break;
                case 'frost': drawFrostCursor(scale); break;
                default: drawDefaultCursor(scale); break;
            }
        }
        
        function drawDragon() {
             if (!dragon.segments || dragon.segments.length === 0) return;
             const difficulty = gameState.difficulty;
             const time = Date.now();

            for (let i = dragon.segments.length - 1; i >= 1; i--) {
                const seg = dragon.segments[i];
                const scale = 1 - (i / dragon.segments.length);
                ctx.save();
                ctx.translate(seg.x, seg.y);
                ctx.rotate(seg.angle);
                const bodyWidth = (15 + Math.sin(i * 0.5 + time/200) * 2) * scale;
                const bodyLength = 15;
                const grad = ctx.createLinearGradient(-bodyWidth, 0, bodyWidth, 0);
                grad.addColorStop(0, '#8B0000');
                grad.addColorStop(0.5, '#FFD700');
                grad.addColorStop(1, '#8B0000');
                ctx.fillStyle = grad;
                ctx.beginPath();
                ctx.ellipse(0, 0, bodyLength, bodyWidth, 0, 0, Math.PI * 2);
                ctx.fill();

                // EVOLUTION: Spikes and Mane
                if (difficulty >= 10 && i % 4 === 0) {
                     ctx.fillStyle = '#F0E68C';
                     ctx.beginPath();
                     ctx.moveTo(0, -bodyWidth);
                     ctx.lineTo(-5 * scale, -bodyWidth - 10 * scale);
                     ctx.lineTo(5 * scale, -bodyWidth - 10 * scale);
                     ctx.closePath();
                     ctx.fill();
                } else {
                    const maneHeight = 25 * scale * (1 + Math.sin(time / 150 + i / 3));
                    ctx.beginPath();
                    ctx.moveTo(0, -bodyWidth);
                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.5 * scale})`;
                    ctx.lineWidth = 3 * scale;
                    ctx.quadraticCurveTo(maneHeight/2, -bodyWidth - maneHeight/2, 0, -bodyWidth - maneHeight);
                    ctx.stroke();
                }
                ctx.restore();
            }
            
            const head = dragon.segments[0];
            ctx.save();
            ctx.translate(head.x, head.y);
            ctx.rotate(head.angle);

            // Base Head
            ctx.fillStyle = '#b22222';
            ctx.beginPath(); ctx.ellipse(30, 0, 35, 12, 0, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = '#8B0000';
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI * 2); ctx.fill();
            
            // EVOLUTION: Head Armor
            if (difficulty >= 15) {
                ctx.fillStyle = '#555';
                ctx.beginPath();
                ctx.moveTo(0, -18); ctx.lineTo(30, -15); ctx.lineTo(30, 15); ctx.lineTo(0, 18);
                ctx.closePath();
                ctx.fill();
            }

            // EVOLUTION: Horns
            ctx.fillStyle = '#F0E68C';
            if (difficulty >= 5) {
                const hornSize = difficulty >= 10 ? 60 : 40;
                const hornCurve = difficulty >= 10 ? -55 : -40;
                ctx.beginPath();
                ctx.moveTo(-5, -18); ctx.quadraticCurveTo(-20, hornCurve, -10, -hornSize); ctx.quadraticCurveTo(-5, -35, -5, -18);
                ctx.moveTo(5, -18); ctx.quadraticCurveTo(20, hornCurve, 10, -hornSize); ctx.quadraticCurveTo(5, -35, 5, -18);
                ctx.fill();
            }

            // Eyes
            const eyeColor = difficulty >= 15 ? '#ff4d4d' : 'yellow';
            ctx.fillStyle = eyeColor;
            if (difficulty >= 15) { ctx.shadowColor = eyeColor; ctx.shadowBlur = 15; }
            ctx.beginPath(); ctx.arc(15, -5, 5, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(15, 5, 5, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'black';
            ctx.beginPath(); ctx.arc(17, -5, 2, 0, Math.PI * 2); ctx.fill();
            ctx.beginPath(); ctx.arc(17, 5, 2, 0, Math.PI * 2); ctx.fill();

            // Whiskers
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(55, 0);
            ctx.bezierCurveTo(70, -15, 80, -10, 90, -20 + Math.sin(time/200)*5);
            ctx.moveTo(55, 0);
            ctx.bezierCurveTo(70, 15, 80, 10, 90, 20 + Math.sin(time/200)*5);
            ctx.stroke();

            // Frozen effect
            if(dragon.frozenTimer > 0) {
                ctx.fillStyle = `rgba(0, 255, 255, ${0.4 * (dragon.frozenTimer/750)})`;
                ctx.beginPath(); ctx.arc(0, 0, 40, 0, Math.PI*2); ctx.fill();
            }

            ctx.restore();

            // Draw Whelp
            if (dragon.whelp) {
                const whelp = dragon.whelp;
                if (whelp.spawnTimer > 0) {
                    const size = whelp.size * (1 - whelp.spawnTimer / 100);
                    ctx.fillStyle = `rgba(139, 0, 0, ${1 - whelp.spawnTimer / 100})`;
                    ctx.beginPath(); ctx.arc(whelp.x, whelp.y, size, 0, Math.PI * 2); ctx.fill();
                } else {
                    ctx.fillStyle = '#8B0000';
                    ctx.beginPath(); ctx.arc(whelp.x, whelp.y, whelp.size, 0, Math.PI * 2); ctx.fill();
                    ctx.fillStyle = 'yellow';
                    const angleToPlayer = Math.atan2(mouse.y - whelp.y, mouse.x - whelp.x);
                    ctx.beginPath(); ctx.arc(whelp.x + Math.cos(angleToPlayer) * 4, whelp.y + Math.sin(angleToPlayer) * 4, 3, 0, Math.PI * 2); ctx.fill();
                }
            }
        }
        
        function drawParticles() {
             particles.forEach(p => {
                if (p.isBurst) { p.x += p.vx; p.y += p.vy; }
                ctx.fillStyle = p.color;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            });
            fireParticles.forEach(p => {
                const grad = ctx.createRadialGradient(p.x, p.y, 1, p.x, p.y, p.size);
                grad.addColorStop(0, 'rgba(255, 255, 100, 1)');
                grad.addColorStop(0.6, 'rgba(255, 100, 0, 0.8)');
                grad.addColorStop(1, 'rgba(255, 0, 0, 0)');
                ctx.fillStyle = grad;
                ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2); ctx.fill();
            });
        }

        // --- Orb Drawing Helpers ---
        function drawNormalOrb(orb) {
            ctx.fillStyle = orb.color;
            ctx.beginPath();
            ctx.arc(0, 0, orb.size, 0, Math.PI * 2);
            ctx.fill();
        }
        function drawShieldOrb(orb) {
            const s = orb.size;
            ctx.fillStyle = orb.color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-s*0.8, -s);
            ctx.lineTo(-s*0.8, s*0.2);
            ctx.quadraticCurveTo(0, s*1.2, s*0.8, s*0.2);
            ctx.lineTo(s*0.8, -s);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        function drawSlowmoOrb(orb) {
            const s = orb.size;
            ctx.fillStyle = orb.color;
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -s * 0.7);
            ctx.moveTo(0, 0);
            ctx.lineTo(s * 0.5, 0);
            ctx.stroke();
        }
        function drawMegaOrb(orb) {
            const s = orb.size;
            const spikes = 8;
            const outerRadius = s * 1.2;
            const innerRadius = s * 0.7;
            ctx.fillStyle = orb.color;
            ctx.strokeStyle = '#ff8c00';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < spikes; i++) {
               const angle = (i / spikes) * Math.PI * 2;
               const xOuter = Math.cos(angle) * outerRadius;
               const yOuter = Math.sin(angle) * outerRadius;
               const angleInner = angle + (Math.PI / spikes);
               const xInner = Math.cos(angleInner) * innerRadius;
               const yInner = Math.sin(angleInner) * innerRadius;
               if (i === 0) { ctx.moveTo(xOuter, yOuter); } else { ctx.lineTo(xOuter, yOuter); }
               ctx.lineTo(xInner, yInner);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
        }
        function drawMagnetOrb(orb) {
            const s = orb.size;
            ctx.strokeStyle = orb.color;
            ctx.lineWidth = s * 0.5;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.arc(0, s * 0.2, s * 0.8, Math.PI, 0);
            ctx.stroke();
            ctx.fillStyle = '#c0c0c0'; // Silver part
            ctx.fillRect(-s*0.8 - s*0.25, s*0.2, s*0.5, s*0.3);
            ctx.fillRect(s*0.8 - s*0.25, s*0.2, s*0.5, s*0.3);
        }
        function drawCoinDoublerOrb(orb) {
            const s = orb.size;
            const grad = ctx.createRadialGradient(0, 0, 1, 0, 0, s);
            grad.addColorStop(0, '#FFFFFF');
            grad.addColorStop(1, '#c0c0c0');
            ctx.fillStyle = grad;
            ctx.strokeStyle = '#a9a9a9';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#808080';
            ctx.font = `bold ${s * 1.2}px 'Cinzel Decorative'`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('2x', 0, 0);
        }
        // End of Orb Drawing Helpers

        function drawOrbs() {
            orbs.forEach(orb => {
                ctx.save();
                ctx.translate(orb.x, orb.y);
                
                ctx.shadowColor = orb.shadow;
                ctx.shadowBlur = 20;

                switch(orb.type) {
                    case 'normal': drawNormalOrb(orb); break;
                    case 'shield': drawShieldOrb(orb); break;
                    case 'slowmo': drawSlowmoOrb(orb); break;
                    case 'mega': drawMegaOrb(orb); break;
                    case 'magnet': drawMagnetOrb(orb); break;
                    case 'coinDoubler': drawCoinDoublerOrb(orb); break;
                }
                
                ctx.restore();
            });
            ctx.shadowBlur = 0;
        }

        function drawMines() {
            mines.forEach(mine => {
                ctx.save();
                ctx.translate(mine.x, mine.y);
                ctx.rotate(mine.angle);
                ctx.shadowColor = `rgba(255, 100, 0, 0.7)`;
                ctx.shadowBlur = 15 + mine.pulse;
                ctx.beginPath();
                ctx.moveTo(mine.points[0].x, mine.points[0].y);
                for (let i = 1; i < mine.points.length; i++) {
                    ctx.lineTo(mine.points[i].x, mine.points[i].y);
                }
                ctx.closePath();
                const grad = ctx.createRadialGradient(0, 0, mine.radius * 0.5, 0, 0, mine.radius);
                grad.addColorStop(0, '#6F4E37');
                grad.addColorStop(1, '#2B1B17');
                ctx.fillStyle = grad;
                ctx.fill();
                ctx.shadowBlur = 0;
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                mine.points.forEach((p, i) => {
                    if (i % 3 === 0) {
                        ctx.beginPath();
                        ctx.arc(p.x * 0.6, p.y * 0.6, mine.radius * 0.15, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                ctx.restore();
            });
            ctx.shadowBlur = 0;
        }
        function drawShockwave() {
            if(dash.shockwave) {
                const sw = dash.shockwave;
                ctx.strokeStyle = `rgba(0, 170, 255, ${sw.opacity})`;
                ctx.lineWidth = 5;
                ctx.beginPath(); ctx.arc(sw.x, sw.y, sw.radius, 0, Math.PI * 2); ctx.stroke();
            }

            tailShockwaves.forEach(tsw => {
                 ctx.strokeStyle = `rgba(255, 215, 0, ${tsw.opacity})`;
                ctx.lineWidth = 3;
                ctx.beginPath(); ctx.arc(tsw.x, tsw.y, tsw.radius, 0, Math.PI * 2); ctx.stroke();
            });
        }
        function drawShield() {
            const shieldRadius = gameState.baseHitboxRadius * gameState.cursorSize + 5;
            const opacity = Math.min(1, powerups.shield.timer / 1000);
            ctx.strokeStyle = `rgba(0, 170, 255, ${opacity * 0.8})`;
            ctx.fillStyle = `rgba(0, 170, 255, ${opacity * 0.2})`;
            ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(mouse.x, mouse.y, shieldRadius, 0, Math.PI * 2);
            ctx.fill(); ctx.stroke();
        }
        function drawMagnetEffect() {
            const opacity = Math.min(1, powerups.magnet.timer / 2000);
            ctx.strokeStyle = `rgba(255, 255, 0, ${opacity * 0.5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(mouse.x, mouse.y, 150, 0, Math.PI*2);
            ctx.stroke();
        }

        // --- SAVE/LOAD ---
        function saveGameData() {
            try {
                const data = {
                    highScore: gameState.highScore,
                    coins: gameState.coins,
                    upgrades: upgrades
                };
                localStorage.setItem('dragonChaseGameData', JSON.stringify(data));
            } catch (e) {
                console.error("Could not save game data.", e);
            }
        }

        function loadGameData() {
            try {
                const data = JSON.parse(localStorage.getItem('dragonChaseGameData'));
                if(data) {
                    gameState.highScore = data.highScore || 0;
                    gameState.coins = data.coins || 0;
                    if(data.upgrades) {
                        upgrades = { ...upgrades, ...data.upgrades };
                    }
                }
            } catch (e) {
                console.error("Could not load game data.", e);
            }
        }
        
        // --- SHOP LOGIC ---
        function updateShopUI() {
            shopCoinDisplay.textContent = `Coins: ${gameState.coins}`;
            
            // Cooldown Upgrade
            const cooldownCost = 100 * Math.pow(1.5, upgrades.cooldownReduction);
            buyCooldownButton.dataset.cost = Math.floor(cooldownCost);
            buyCooldownButton.querySelector('.item-cost').textContent = Math.floor(cooldownCost);
            buyCooldownButton.disabled = gameState.coins < cooldownCost || upgrades.cooldownReduction >= 10;
            cooldownLevelEl.textContent = `Level ${upgrades.cooldownReduction} / 10`;

            // Duration Upgrade
            const durationCost = 150 * Math.pow(1.5, upgrades.durationIncrease);
            buyDurationButton.dataset.cost = Math.floor(durationCost);
            buyDurationButton.querySelector('.item-cost').textContent = Math.floor(durationCost);
            buyDurationButton.disabled = gameState.coins < durationCost || upgrades.durationIncrease >= 10;
            durationLevelEl.textContent = `Level ${upgrades.durationIncrease} / 10`;
            
            // Shield Upgrade
            buyShieldButton.dataset.cost = 500;
            buyShieldButton.disabled = gameState.coins < 500 || upgrades.startingShield;
            shieldLevelEl.textContent = upgrades.startingShield ? "Purchased" : "Not Owned";
            if(upgrades.startingShield) buyShieldButton.textContent = "Owned";

            // Cursor Skins
            cursorSkinContainer.innerHTML = '';
            for(const skinId in cursorSkins) {
                const skin = cursorSkins[skinId];
                const item = document.createElement('div');
                item.className = 'shop-item';
                
                const isPurchased = upgrades.purchasedSkins.includes(skinId);
                const isEquipped = upgrades.cursorSkin === skinId;

                let buttonHTML;
                if (isEquipped) {
                    buttonHTML = `<button disabled>Equipped</button>`;
                } else if (isPurchased) {
                    buttonHTML = `<button class="equip-skin-btn" data-skin="${skinId}">Equip</button>`;
                } else {
                    buttonHTML = `<button class="buy-skin-btn" data-skin="${skinId}" data-cost="${skin.cost}" ${gameState.coins < skin.cost ? 'disabled' : ''}>Buy <span class="item-cost">${skin.cost}</span></button>`;
                }

                item.innerHTML = `
                    <div class="cursor-skin-header">
                        <p>${skin.name}</p>
                        ${buttonHTML}
                    </div>
                    <p class="skin-description">${skin.description}</p>
                `;
                cursorSkinContainer.appendChild(item);
            }
        }
        
        function buySkin(skinId) {
            const skin = cursorSkins[skinId];
            if (skin && gameState.coins >= skin.cost && !upgrades.purchasedSkins.includes(skinId)) {
                gameState.coins -= skin.cost;
                upgrades.purchasedSkins.push(skinId);
                equipSkin(skinId);
            }
        }

        function equipSkin(skinId) {
            if (upgrades.purchasedSkins.includes(skinId)) {
                upgrades.cursorSkin = skinId;
                saveGameData();
                updateShopUI();
            }
        }


        function buyUpgrade(type) {
            let cost = 0;
            switch(type) {
                case 'cooldown':
                    cost = parseInt(buyCooldownButton.dataset.cost);
                    if (gameState.coins >= cost && upgrades.cooldownReduction < 10) {
                        gameState.coins -= cost;
                        upgrades.cooldownReduction++;
                    }
                    break;
                case 'duration':
                    cost = parseInt(buyDurationButton.dataset.cost);
                    if (gameState.coins >= cost && upgrades.durationIncrease < 10) {
                        gameState.coins -= cost;
                        upgrades.durationIncrease++;
                    }
                    break;
                case 'shield':
                    cost = parseInt(buyShieldButton.dataset.cost);
                    if (gameState.coins >= cost && !upgrades.startingShield) {
                        gameState.coins -= cost;
                        upgrades.startingShield = true;
                    }
                    break;
            }
            saveGameData();
            updateShopUI();
            updateMainMenuUI();
        }

        function resetGameData() {
            localStorage.removeItem('dragonChaseGameData');
            gameState.highScore = 0;
            gameState.coins = 0;
            upgrades = {
                cooldownReduction: 0,
                durationIncrease: 0,
                startingShield: false,
                cursorSkin: 'default',
                purchasedSkins: ['default']
            };
            showMainMenu();
        }

        function showMainMenu() {
            isGameStarted = false;
            isGameOver = false; // Reset game over state
            startModal.style.display = 'flex';
            gameOverModal.style.display = 'none';
            rulesModal.style.display = 'none';
            shopModal.style.display = 'none';
            resetConfirmModal.style.display = 'none';
            canvas.style.filter = 'none';
            updateMainMenuUI();
            if(!animationFrameId) gameLoop(); // Restart loop if it was stopped
        }

        function updateMainMenuUI() {
            highScoreElement.textContent = `High Score: ${gameState.highScore}`;
            coinDisplay.textContent = `Coins: ${gameState.coins}`;
        }

        function triggerDash() {
            if (dash.ready && !isGameOver && !isPaused) {
                playSound("F3", "8n");
                dash.ready = false;
                dash.timer = dash.cooldown;
                const radius = dash.isMega ? 60 : 20;
                const speed = dash.isMega ? 25 : 15;
                dash.shockwave = { x: mouse.x, y: mouse.y, radius: radius, opacity: 1, speed: speed };
                dash.isMega = false;
            }
        }

        // --- EVENT LISTENERS ---
        window.addEventListener('resize', () => { if (isGameStarted) init(); });
        
        document.addEventListener('mousemove', e => { 
            cursorTarget.x = e.clientX; 
            cursorTarget.y = e.clientY; 
        });

        // Touch controls for mobile
        document.addEventListener('touchstart', e => {
            e.preventDefault();
            if (e.touches.length > 0) {
                cursorTarget.x = e.touches[0].clientX;
                cursorTarget.y = e.touches[0].clientY;
            }
        }, { passive: false });

        document.addEventListener('touchmove', e => {
            e.preventDefault();
            if (e.touches.length > 0) {
                cursorTarget.x = e.touches[0].clientX;
                cursorTarget.y = e.touches[0].clientY;
            }
        }, { passive: false });


        window.addEventListener('keydown', e => {
            if (e.code === 'Space') {
                triggerDash();
            }
            if (e.code === 'KeyP' && isGameStarted && !isGameOver) {
                isPaused = !isPaused;
                pauseModal.style.display = isPaused ? 'flex' : 'none';
                if(isPaused) { Tone.Transport.pause(); canvas.style.filter = 'blur(5px)'; } 
                else { Tone.Transport.start(); canvas.style.filter = 'none'; }
            }
        });

        mobilePushbackButton.addEventListener('click', triggerDash);

        // MENU BUTTONS
        playButton.addEventListener('click', () => {
            isGameStarted = true;
            startModal.style.display = 'none';
            init();
        });

        rulesButton.addEventListener('click', () => {
            startModal.style.display = 'none';
            rulesModal.style.display = 'flex';
        });

        shopButton.addEventListener('click', () => {
            startModal.style.display = 'none';
            updateShopUI();
            shopModal.style.display = 'flex';
        });
        
        resetButton.addEventListener('click', () => {
            startModal.style.display = 'none';
            resetConfirmModal.style.display = 'flex';
        });

        cancelResetButton.addEventListener('click', showMainMenu);
        confirmResetButton.addEventListener('click', resetGameData);


        rulesBackButton.addEventListener('click', showMainMenu);
        shopBackButton.addEventListener('click', showMainMenu);

        restartButton.addEventListener('click', () => {
             canvas.style.filter = 'none';
             init();
             Tone.Transport.start();
        });
        
        mainMenuButton.addEventListener('click', showMainMenu);

        buyCooldownButton.addEventListener('click', () => buyUpgrade('cooldown'));
        buyDurationButton.addEventListener('click', () => buyUpgrade('duration'));
        buyShieldButton.addEventListener('click', () => buyUpgrade('shield'));

        shopModal.addEventListener('click', (e) => {
            const buyButton = e.target.closest('.buy-skin-btn');
            const equipButton = e.target.closest('.equip-skin-btn');
            if (buyButton) {
                buySkin(buyButton.dataset.skin);
            } else if (equipButton) {
                equipSkin(equipButton.dataset.skin);
            }
        });


        // --- PWA Service Worker Registration ---
        if ('serviceWorker' in navigator) {
            const swJS = `
                const CACHE_NAME = 'dragon-chase-v1';
                const urlsToCache = [
                    './',
                    'https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js',
                    'https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@400;700&display=swap'
                ];

                self.addEventListener('install', event => {
                    event.waitUntil(
                        caches.open(CACHE_NAME)
                            .then(cache => {
                                console.log('Opened cache');
                                return cache.addAll(urlsToCache);
                            })
                    );
                });

                self.addEventListener('fetch', event => {
                    event.respondWith(
                        caches.match(event.request)
                            .then(response => {
                                if (response) {
                                    return response;
                                }
                                return fetch(event.request);
                            }
                        )
                    );
                });
            `;
            const swBlob = new Blob([swJS], {type: 'application/javascript'});
            const swUrl = URL.createObjectURL(swBlob);

            window.addEventListener('load', () => {
                navigator.serviceWorker.register(swUrl).then(registration => {
                    console.log('ServiceWorker registration successful with scope: ', registration.scope);
                }, err => {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }

        function setupForMobile() {
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
            if (isMobile) {
                document.getElementById('dash-status').style.display = 'none';
                document.getElementById('controls-rule').innerHTML = '<strong>Controls:</strong> Move your finger to navigate. Tap the ⚡ button for Pushback.';
                mobilePushbackButton.style.display = 'block';
            }
        }

        // --- INITIAL LOAD ---
        startOverlay.addEventListener('click', async () => {
            await Tone.start(); // Unlock audio context
            Tone.Transport.start();
            startOverlay.style.display = 'none';
            
            loadGameData();
            showMainMenu();
            createStarfield();
            setupForMobile();
            gameLoop();

        }, { once: true });
    </script>
</body>
</html>

